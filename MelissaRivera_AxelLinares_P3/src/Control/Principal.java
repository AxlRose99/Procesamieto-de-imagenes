

package Control;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JSlider;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;

public class Principal extends javax.swing.JFrame {
    
    JFileChooser save;
    Mat image,image2,imageGa,imageNeg,imageNeg2,imageBin,imageBin2,imageNF,imageAvg,imageGaussian,imageMedian,imageRota,imageRota2;
    BufferedImage imag;
    int umbral=120,valorB=0,valorC=0,valorNeg=0,valorBin=0,valorRota,rotacion;
    double escala;
    double [][] avg = {{1.0/9, 1.0/9, 1.0/9}, {1.0/9, 1.0/9, 1.0/9}, {1.0/9, 1.0/9, 1.0/9}};
    double [][] gauss = {{1.0/16, 2.0/16, 1.0/16}, {2.0/16, 4.0/16, 2.0/16}, {1.0/16, 2.0/16, 1.0/16}};
    
    public Principal() {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        initComponents();
        save=new JFileChooser();
        brillo.setEnabled(false);
        contraste.setEnabled(false);
        gamma.setEnabled(false);
        negativo.setEnabled(false);
        binariza.setEnabled(false);
        averaging.setEnabled(false);
        gaussian.setEnabled(false);
        median.setEnabled(false);
        rotar.setEnabled(false);
        guardar.setEnabled(false);
        original.setEnabled(false);
        escalaE.setEnabled(false);
        grados.setEnabled(false);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        label = new javax.swing.JLabel();
        cargar = new javax.swing.JButton();
        brillo = new javax.swing.JSlider();
        contraste = new javax.swing.JSlider();
        negativo = new javax.swing.JCheckBox();
        gamma = new javax.swing.JSlider();
        binariza = new javax.swing.JCheckBox();
        guardar = new javax.swing.JButton();
        original = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        averaging = new javax.swing.JSlider();
        gaussian = new javax.swing.JSlider();
        median = new javax.swing.JSlider();
        rotar = new javax.swing.JCheckBox();
        escalaE = new javax.swing.JTextField();
        grados = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        cargar.setText("Cargar");
        cargar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cargarActionPerformed(evt);
            }
        });

        brillo.setMajorTickSpacing(1);
        brillo.setMaximum(10);
        brillo.setMinimum(-10);
        brillo.setPaintTicks(true);
        brillo.setToolTipText("");
        brillo.setValue(0);
        brillo.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                brilloStateChanged(evt);
            }
        });

        contraste.setMajorTickSpacing(1);
        contraste.setMaximum(10);
        contraste.setMinimum(-10);
        contraste.setPaintTicks(true);
        contraste.setValue(0);
        contraste.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                contrasteStateChanged(evt);
            }
        });

        negativo.setText("Negativo");
        negativo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                negativoActionPerformed(evt);
            }
        });

        gamma.setMajorTickSpacing(1);
        gamma.setMaximum(5);
        gamma.setPaintTicks(true);
        gamma.setToolTipText("");
        gamma.setValue(0);
        gamma.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                gammaStateChanged(evt);
            }
        });

        binariza.setText("Binarizaci√≥n");
        binariza.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binarizaActionPerformed(evt);
            }
        });

        guardar.setText("Guardar");
        guardar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                guardarActionPerformed(evt);
            }
        });

        original.setText("Original");
        original.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                originalActionPerformed(evt);
            }
        });

        jLabel1.setText("Gamma");

        jLabel2.setText("Contraste");

        jLabel3.setText("Brillo");

        jLabel4.setText("Averaging");

        jLabel5.setText("Median");

        jLabel6.setText("Gaussian");

        averaging.setMajorTickSpacing(1);
        averaging.setMaximum(5);
        averaging.setPaintTicks(true);
        averaging.setToolTipText("");
        averaging.setValue(0);
        averaging.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                averagingStateChanged(evt);
            }
        });

        gaussian.setMajorTickSpacing(1);
        gaussian.setMaximum(5);
        gaussian.setPaintTicks(true);
        gaussian.setValue(0);
        gaussian.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                gaussianStateChanged(evt);
            }
        });

        median.setMajorTickSpacing(1);
        median.setMaximum(5);
        median.setPaintTicks(true);
        median.setValue(0);
        median.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                medianStateChanged(evt);
            }
        });

        rotar.setText("Rotar");
        rotar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rotarActionPerformed(evt);
            }
        });

        jLabel7.setText("Escala");

        jLabel8.setText("Grados");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(label, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(brillo, javax.swing.GroupLayout.DEFAULT_SIZE, 580, Short.MAX_VALUE)
                            .addComponent(contraste, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(gamma, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(averaging, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(gaussian, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(median, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(282, 282, 282)
                        .addComponent(jLabel2))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(299, 299, 299)
                        .addComponent(jLabel3))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(296, 296, 296)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(299, 299, 299)
                        .addComponent(jLabel4))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(309, 309, 309)
                        .addComponent(jLabel6))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(316, 316, 316)
                        .addComponent(jLabel5)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(101, 101, 101)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(cargar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(guardar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(original, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(binariza, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(negativo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addComponent(escalaE, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 145, Short.MAX_VALUE)
                                .addComponent(grados, javax.swing.GroupLayout.Alignment.LEADING))
                            .addComponent(rotar)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel7)
                                .addGap(50, 50, 50))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel8)
                                .addGap(40, 40, 40)))))
                .addContainerGap(32, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(label, javax.swing.GroupLayout.PREFERRED_SIZE, 380, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(cargar))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(brillo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(contraste, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(gamma, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(averaging, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(guardar)
                                .addGap(31, 31, 31)
                                .addComponent(original)
                                .addGap(43, 43, 43)
                                .addComponent(binariza)
                                .addGap(26, 26, 26)
                                .addComponent(negativo)
                                .addGap(33, 33, 33)
                                .addComponent(jLabel7)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(escalaE, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(11, 11, 11)
                                .addComponent(jLabel8)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel6)
                            .addComponent(grados, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(gaussian, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(rotar))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(median, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(91, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    
    
    private void cargarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cargarActionPerformed
        selectImage();
        image2=image.clone();
    }//GEN-LAST:event_cargarActionPerformed

    private void brilloStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_brilloStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=(int)source.getValue();

        if(contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0 && rotar.isSelected()==false){
            if(level>0){
                valorB=level;
                sumarPixeles(image.clone(),level);
            }
            else if(level<0){
                valorB=level;
                restarPixeles(image.clone(), level);
            }
            else{
                valorB=level;
                image2=image.clone();
                setImage(image); 
            }
        }
        else {
            if(gamma.getValue()>0 && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                if (valorB>level){
                    valorB=level;
                    imageGa=restarPixeles(imageGa.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    imageGa=sumarPixeles(imageGa.clone(),1);
                }
            }
            else if(gamma.getValue()>0 && (averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0)){
                if (valorB>level){
                    valorB=level;
                    imageGa=restarPixeles(imageGa.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    imageGa=sumarPixeles(imageGa.clone(),1);
                }
            }
            else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                if (valorB>level){
                    valorB=level;
                    imageNF=restarPixeles(imageNF.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    imageNF=sumarPixeles(imageNF.clone(),1);
                }
            }
            else{
                if (valorB>level){
                    valorB=level;
                    image2=restarPixeles(image2.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    image2=sumarPixeles(image2.clone(),1);
                }
            }
        }
    }//GEN-LAST:event_brilloStateChanged

    private void contrasteStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_contrasteStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=(int)source.getValue();
        
        if(brillo.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0 && rotar.isSelected()==false){
            if(level<0){
                valorC=level;
                level=level*5;
                contraste(image.clone(),level);
            }
            else if(level>0){
                valorC=level;
                level=level*5;
                contraste(image.clone(),level);
            }
            else{
                valorC=level;
                image2=image.clone();
                setImage(image); 
            }
        } else{
            if(gamma.getValue()>0 && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                if(valorC>level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),5);
                }
            }
            else if(gamma.getValue()>0 && (averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0)){
                if(valorC>level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),5);
                }
            }
            else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                if(valorC>level){
                    valorC=level;
                    imageNF=contraste(imageNF.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    imageNF=contraste(imageNF.clone(),5);
                }
            }
            else{
                if(valorC>level){
                    valorC=level;
                    image2=contraste(image2.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    image2=contraste(image2.clone(),5);
                }
            }
        }
    }//GEN-LAST:event_contrasteStateChanged

    private void negativoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_negativoActionPerformed
        if(negativo.isSelected()==true){
            if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                valorNeg=1;
                image2=negativo(image.clone());
            } 
            else{
                imageNeg=image2.clone();
                
                if(gamma.getValue()>0){
                    valorNeg=2;
                    imageNeg2=imageGa.clone();
                    
                    image2=negativo(image2.clone());
                    imageGa=negativo(imageGa.clone());   
                }
                else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0 ){
                    valorNeg=4;
                    imageNeg2=imageNF.clone();
                    
                    image2=negativo(image2.clone());
                    imageNF=negativo(imageNF.clone());   
                }
                else{
                    valorNeg=3;
                    image2=negativo(image2.clone());
                }
               
            }
        } else{
            switch (valorNeg) {
                case 1:
                    image2=image.clone();
                    setImage(image);
                    break;
                case 2:
                    image2=imageNeg.clone();
                    imageGa=imageNeg2.clone();
                    setImage(imageGa);
                    break;
                case 3:
                    image2=imageNeg.clone();
                    setImage(image2);
                    break;
                case 4:
                    image2=imageNeg.clone();
                    imageNF=imageNeg2.clone();
                    setImage(imageNF);
                    break;
            }
        }
    }//GEN-LAST:event_negativoActionPerformed

    private void gammaStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_gammaStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        double g;
        
        if(contraste.getValue()==0 && brillo.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0 && rotar.isSelected()==false){
            if(level>0){
                g=level*1.05;
                gamma(image.clone(),g);
            }
            else{
                image2=image.clone();
                setImage(image); 
            }
        }
        else{
            if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                if(level>0){
                    g=level*1.05;
                    gamma(imageNF.clone(),g);
                }
                else{
                    setImage(imageNF); 
                }
            } else{
                if(level>0){
                    g=level*1.05;
                    gamma(image2.clone(),g);
                }
                else{
                    setImage(image2); 
                }
            }
        }
        
        
    }//GEN-LAST:event_gammaStateChanged

    private void binarizaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binarizaActionPerformed
        if(binariza.isSelected()==true){
            if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                valorBin=1;
                image2=binariza(image.clone());
            } 
            else{
                imageBin=image2.clone();
                
                if(gamma.getValue()>0){
                    valorBin=2;
                    imageBin2=imageGa.clone();
                    
                    image2=binariza(image2.clone());
                    imageGa=binariza(imageGa.clone());   
                }
                else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                    valorBin=3;
                    imageBin2=imageNF.clone();
                    //se cambio imageNF por image2
                    image2=binariza(image2.clone());
                    imageNF=binariza(imageNF.clone());  
                }
                else{
                    valorBin=4;
                    image2=binariza(image2.clone());
                }
            }
        } else{
             switch (valorBin) {
                case 1:
                    image2=image.clone();
                    setImage(image);
                    break;
                case 2:
                    image2=imageBin.clone();
                    imageGa=imageBin2.clone();
                    setImage(imageGa);
                    break;
                case 3:
                    image2=imageBin.clone();
                    imageNF=imageBin2.clone();
                    setImage(imageNF);
                    break;
                case 4:
                    image2=imageBin.clone();
                    setImage(image2);
                    break;
            }
        }
    }//GEN-LAST:event_binarizaActionPerformed

    private void guardarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_guardarActionPerformed
        save.showSaveDialog(this);
       
        try {
            ImageIO.write(imag, "png",save.getSelectedFile());
        } catch (IOException e) {
        }
    }//GEN-LAST:event_guardarActionPerformed

    private void originalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_originalActionPerformed
        valorB=0;
        valorC=0;
        brillo.setValue(0);
        contraste.setValue(0);
        gamma.setValue(0);
        negativo.setSelected(false);
        binariza.setSelected(false);
        rotar.setSelected(false);
        averaging.setValue(0);
        gaussian.setValue(0);
        median.setValue(0);
        escalaE.setText("");
        grados.setText("");
        
        image2=image.clone();
        setImage(image);
    }//GEN-LAST:event_originalActionPerformed

    private void averagingStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_averagingStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        Mat imageAux;
        
        if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && gaussian.getValue()==0 && median.getValue()==0 && rotar.isSelected()==false){
            if(averaging.getValue()>0){
                imageAux=image.clone();
                for(int i=1;i<=level;i++){
                averaging(imageAux);
                }
            }
            else{
                image2=image.clone();
                setImage(image);
            }
        } else{
            if(gamma.getValue()>0 && gaussian.getValue()==0 && median.getValue()==0){
                if(averaging.getValue()>0){
                    imageAux=imageGa.clone();
                    for(int i=1;i<=level;i++){
                    averaging(imageAux);
                    }
                    imageGa=imageNF.clone();
                } else{
//                    imageGa=imageAvg.clone();
                    setImage(imageGa);
                }
            }
            else if(gaussian.getValue()>0 || median.getValue()>0){
                if(averaging.getValue()>0){
                    imageAvg=imageNF.clone();
                    imageAux=imageNF.clone();
                    for(int i=1;i<=level;i++){
                    averaging(imageAux);
                    }
                    imageNF=imageAvg.clone();
                } else{
                    setImage(imageNF);
                }
            } else{
                if(averaging.getValue()>0){
                    imageAux=image2.clone();
                    for(int i=1;i<=level;i++){
                    averaging(imageAux);
                    }
                } else{
                    setImage(image2);
                }
            }
        }
    }//GEN-LAST:event_averagingStateChanged

    private void gaussianStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_gaussianStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        Mat imageAux;
        
        if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && median.getValue()==0 && rotar.isSelected()==false){
            if(gaussian.getValue()>0){
                imageAux=image.clone();
                for(int i=1;i<=level;i++){
                gaussian(imageAux);
                }
            }
            else{
                image2=image.clone();
                setImage(image);
            }
        } else{
            if(gamma.getValue()>0 && averaging.getValue()==0 && median.getValue()==0){
                if(gaussian.getValue()>0){
                    imageAux=imageGa.clone();
                    for(int i=1;i<=level;i++){
                    gaussian(imageAux);
                    }
                    imageGa=imageNF.clone();
                } else{
                    setImage(imageGa);
                }
            }
            else if(averaging.getValue()>0 || median.getValue()>0){
                if(gaussian.getValue()>0){
                    imageGaussian=imageNF.clone();
                    imageAux=imageNF.clone();
                    for(int i=1;i<=level;i++){
                    gaussian(imageAux);
                    }
                    imageNF=imageGaussian.clone();
                } else{
                    setImage(imageNF);
                }
            } else{
                if(gaussian.getValue()>0){
                    imageAux=image2.clone();
                    for(int i=1;i<=level;i++){
                    gaussian(imageAux);
                    }
                } else{
                    setImage(image2);
                }
            }
        }
    }//GEN-LAST:event_gaussianStateChanged

    private void medianStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_medianStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        Mat imageAux;
        
        if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && rotar.isSelected()==false){
            if(median.getValue()>0){
                imageAux=image.clone();
                for(int i=1;i<=level;i++){
                median(imageAux);
                }
            }
            else{
                image2=image.clone();
                setImage(image);
            }
        } else{
            if(gamma.getValue()>0 && averaging.getValue()==0 && gaussian.getValue()==0){
                if(median.getValue()>0){
                    imageAux=imageGa.clone();
                    for(int i=1;i<=level;i++){
                    median(imageAux);
                    }
                    imageGa=imageNF.clone();
                } else{
                    setImage(imageGa);
                }
            }
            else if(averaging.getValue()>0 || gaussian.getValue()>0){
                if(median.getValue()>0){
                    imageMedian=imageNF.clone();
                    imageAux=imageNF.clone();
                    for(int i=1;i<=level;i++){
                    median(imageAux);
                    }
                    imageNF=imageMedian.clone();
                } else{
                    setImage(imageNF);
                }
            } else{
                if(median.getValue()>0){
                    imageAux=image2.clone();
                    for(int i=1;i<=level;i++){
                    median(imageAux);
                    }
                } else{
                    setImage(image2);
                }
            }
        }
    }//GEN-LAST:event_medianStateChanged

    private void rotarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rotarActionPerformed
        int grad=0;
        double esca=0;
        
        if(grados.getText().isEmpty()==false && escalaE.getText().isEmpty()==false){
            try{
            grad = Integer.parseInt(grados.getText());
            esca= Double.parseDouble(escalaE.getText());
            } catch(Exception e){
                JOptionPane.showConfirmDialog(null, "Valores incorrectos","Solo numeros", JOptionPane.CLOSED_OPTION, JOptionPane.ERROR_MESSAGE,null);
            }
        }

        if(rotar.isSelected()==true){
            if(grad>0 && grad<360 && esca>=.1 && esca<=.9){
                escala=esca;
                rotacion=grad;
                if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                valorRota=1;
                image2=scaling(image.clone());
                image2=rotation(image2.clone());
                }
                else{
                    imageRota=image2.clone();

                    if(gamma.getValue()>0){
                        valorRota=2;
                        imageRota2=imageGa.clone();

                        image2=scaling(image2.clone());
                        image2=rotation(image2.clone());
                        imageGa=scaling(imageGa.clone());
                        imageGa=rotation(imageGa.clone());
                    }
                    else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                        valorRota=3;
                        imageRota2=imageNF.clone();

                        image2=scaling(image2.clone());
                        image2=rotation(image2.clone());
                        imageNF=scaling(imageNF.clone());
                        imageNF=rotation(imageNF.clone()); 
                    }
                    else{
                        valorRota=4;
                        image2=scaling(image2.clone());
                        image2=rotation(image2.clone());
                    }
                }
            }
            else{
                rotar.setSelected(false);
                JOptionPane.showConfirmDialog(null, "Escala y Grados incorrectos","Vuelva a introducir los datos", JOptionPane.CLOSED_OPTION, JOptionPane.ERROR_MESSAGE,null);
            }
        } else{
             switch (valorRota) {
                case 1:
                    image2=image.clone();
                    setImage(image);
                    break;
                case 2:
                    image2=imageRota.clone();
                    imageGa=imageRota2.clone();
                    setImage(imageGa);
                    break;
                case 3:
                    image2=imageRota.clone();
                    imageNF=imageRota2.clone();
                    setImage(imageNF);
                    break;
                case 4:
                    image2=imageRota.clone();
                    setImage(image2);
                    break;
            }
            escalaE.setText("");
            grados.setText("");
        }
    }//GEN-LAST:event_rotarActionPerformed
    
    private Mat rotation(Mat imageRot) {
        Mat rota = new Mat(imageRot.rows(), imageRot.cols(), CvType.CV_8UC3);
        int x, y, a=0, b=0;
        double x1 = 0, x2 = 0, x3=0, x4=0;
        
        
        if(rotacion==90){
            x1=image.cols()*escala;
            
            x2=image.rows()*escala;
            x2=(image.cols()-x2)/2;
            b=(int) x2;
            if(x1<image.rows()){
                x2=(image.rows()-x1)/2;
                a=(int) (x1+x2);
            }
            else{
                a=(int) x1;
            }
        }
        else if(rotacion>0 && rotacion<90){
            x1=image.cols()*escala;
            x1=0-x1 * Math.sin(Math.toRadians(rotacion));
            
            x2=image.rows()*escala;
            x2=x2 * Math.cos(Math.toRadians(rotacion));
            x4=image.rows()-x2;
            
            x3=x1+x4;
            if(x3>0){
                x3=x3/2;
                x4=x4-x3;

                a=(int) x4;
                
                x4=(image.rows()*escala)* Math.sin(Math.toRadians(rotacion)) + (image.cols()*escala)* Math.cos(Math.toRadians(rotacion));
                x4=(image.cols()-x4)/2;
                b=(int) x4;
            }
            else{
                a=(int) x4;
            }
        }
        else if(rotacion>90 && rotacion<180){
            x1=(image.rows()*escala)* Math.cos(Math.toRadians(rotacion)) - (image.cols()*escala)* Math.sin(Math.toRadians(rotacion));
            
            x2=image.rows();
            
            x3=x1+x2;
            if(x3>0){
                x3=x3/2;
                x4=image.rows()-x3;

                a=(int) x4;
                
                x2=(image.cols()*escala)* Math.cos(Math.toRadians(rotacion));
                x2=x2*-1;
                
                x1=(image.rows()*escala)* Math.sin(Math.toRadians(rotacion));
                
                x1=(x1+x2);
                x1=(image.cols()-x1)/2;
                x1=(x1+x2);
                b=(int) x1;
            }
            else{                
                a=image.rows();
                
                x1=(image.rows()*escala)* Math.sin(Math.toRadians(rotacion));
                x1=(image.cols()-x1);
                b=(int) x1;
            }
        }
        else if(rotacion==180){
            x1=(image.rows()*escala)* Math.cos(Math.toRadians(rotacion)) - (image.cols()*escala)* Math.sin(Math.toRadians(rotacion));
            
            x2=image.rows();
            
            x3=(x1+x2)/2;

            x4=image.rows()-x3;
            
            a=(int) x4;
                
            x2=(image.cols()*escala);
            x2=(image.cols()-x2)/2;
            x2=(image.cols()-x2);
            b=(int) x2;
        }
        else if(rotacion>180 && rotacion<270){
            x1=(image.rows()*escala)* Math.cos(Math.toRadians(rotacion));
            x1=x1*-1;

            x2=0 - (image.cols()*escala)* Math.sin(Math.toRadians(rotacion));
            
            x3=x2+x1;
            
            if(x3<image.rows()){
                x4=(image.rows()-x3)/2;
                x1=x1+x4;
                a=(int) x1;
                
                x4=(image.rows()*escala)* Math.sin(Math.toRadians(rotacion)) + (image.cols()*escala)* Math.cos(Math.toRadians(rotacion));
                x4=x4*-1;
                
                x1=(image.cols()-x4)/2;
                x1=x1+x4;
                b=(int) x1;
            }
            else{
                a=(int) x1;
                b=image.cols();
            }
        }
        else if(rotacion==270){
            x1=(image.rows()*escala);
            x2=(image.cols()-x1)/2;
            x2=x2+x1;
                
            b=(int) x2;
            
            x3=(image.cols()*escala);
            
            if(x3<image.rows()){
                x4=(image.rows()-x3)/2;
                a=(int) x4;
            }
        }
        else if(rotacion>270 && rotacion<360){
            x1=(image.rows()*escala)* Math.cos(Math.toRadians(rotacion)) - (image.cols()*escala)* Math.sin(Math.toRadians(rotacion));
            
            x4=(image.rows()*escala)* Math.sin(Math.toRadians(rotacion));
            x4=x4*-1;
            if(x1<image.rows()){
                x2=(image.rows()-x1)/2;
                a=(int) x2;
                
                x3=(image.cols()*escala)* Math.cos(Math.toRadians(rotacion));
                x3=x3+x4;
                x3=(image.cols()-x3)/2;
                x3=x3+x4;
                b=(int) x3;
            }
            else {
                b=(int) x4;
            }
        }
        
        for (int i = 0; i < imageRot.rows(); i++) {
            for (int j = 0; j < imageRot.cols(); j++) {
                double[] newSpec = imageRot.get(i, j);
                x1 = i * Math.cos(Math.toRadians(rotacion)) - j * Math.sin(Math.toRadians(rotacion));
                x2 = i * Math.sin(Math.toRadians(rotacion)) + j * Math.cos(Math.toRadians(rotacion));

                x = (int) x1+a;
                y = (int) x2+b;

                if (x >= 0 && x < imageRot.rows() && y >= 0 && y < imageRot.cols()) {
                    rota.put(x, y, newSpec);
                }

            }
        }
        setImage(rota);
        return rota.clone();
    }
    
    private Mat scaling(Mat imageScal) {
        Mat scal = new Mat(imageScal.rows(), imageScal.cols(), CvType.CV_8UC3);
        int x, y;

        for (int i = 0; i < imageScal.rows(); i++) {
            for (int j = 0; j < imageScal.cols(); j++) {
                double[] newSpec = imageScal.get(i, j);
                x = (int) (i * escala);
                y = (int) (j * escala);

                scal.put(x, y, newSpec);
            }
        }
        return scal.clone();
    }
    
    private void averaging(Mat imageAv){
        double[][] m0 = new double[3][3];
        double[][] m1 = new double[3][3];
        double[][] m2 = new double[3][3];
        int x,y;
        for(int i=0;i<imageAv.rows();i++){
            for(int j=0;j<imageAv.cols();j++){
                if(i>0 && i<imageAv.rows()-1 && j>0 && j<imageAv.cols()-1){
                    double[] newSpec;

                    x=0;
                    for(int a=i-1; a<i+2; a++){
                        y=0;
                        for(int b=j-1; b<j+2; b++){

                            newSpec=imageAv.get(a, b);
                            m0[x][y]=newSpec[0];
                            m1[x][y]=newSpec[1];
                            m2[x][y]=newSpec[2];
                            y++;
                        }
                    x++;    
                    }
                    newSpec=imageAv.get(i, j);
                    newSpec[0]=operacion(m0,avg);
                    newSpec[1]=operacion(m1,avg);
                    newSpec[2]=operacion(m2,avg);
                    
                    imageAv.put(i,j,newSpec);
                }

            }
            
        }
        setImage(imageAv);
        imageNF=imageAv.clone();
    }
    
    private void gaussian(Mat imageGauss){
        double[][] m0 = new double[3][3];
        double[][] m1 = new double[3][3];
        double[][] m2 = new double[3][3];
        int x,y;
        for(int i=0;i<imageGauss.rows();i++){
            for(int j=0;j<imageGauss.cols();j++){
                if(i>0 && i<imageGauss.rows()-1 && j>0 && j<imageGauss.cols()-1){
                    double[] newSpec;

                    x=0;
                    for(int a=i-1; a<i+2; a++){
                        y=0;
                        for(int b=j-1; b<j+2; b++){

                            newSpec=imageGauss.get(a, b);
                            m0[x][y]=newSpec[0];
                            m1[x][y]=newSpec[1];
                            m2[x][y]=newSpec[2];
                            y++;
                        }
                    x++;    
                    }
                    newSpec=imageGauss.get(i, j);
                    newSpec[0]=operacion(m0,gauss);
                    newSpec[1]=operacion(m1,gauss);
                    newSpec[2]=operacion(m2,gauss);
                    
                    imageGauss.put(i,j,newSpec);
                }

            }
            
        }
        setImage(imageGauss);
        imageNF=imageGauss.clone();
    }
    
    private void median(Mat imageMed){
        double[] m0 = new double[9];
        double[] m1 = new double[9];
        double[] m2 = new double[9];
        int x;
        for(int i=0;i<imageMed.rows();i++){
            for(int j=0;j<imageMed.cols();j++){
                
                if(i>0 && i<imageMed.rows()-1 && j>0 && j<imageMed.cols()-1){
                    double[] newSpec;

                    x=0;
                    for(int a=i-1; a<i+2; a++){
                        for(int b=j-1; b<j+2; b++){

                            newSpec=imageMed.get(a, b);
                            m0[x]=newSpec[0];
                            m1[x]=newSpec[1];
                            m2[x]=newSpec[2];
                            x++;
                        }    
                    }
                    newSpec=imageMed.get(i, j);
                    
                    Arrays.sort(m0);
                    Arrays.sort(m1);
                    Arrays.sort(m2);
                    
                    newSpec[0]=m0[4];
                    newSpec[1]=m1[4];
                    newSpec[2]=m2[4];
                    
                    imageMed.put(i,j,newSpec);
                }

            }
        }
        setImage(imageMed);
        imageNF=imageMed.clone();
    }
    
    private double operacion(double[][] m1,double[][] m2){
        double r=0;
        
        for(int i=0; i<3;i++){
            for(int j=0;j<3;j++){
                r=r+(m1[i][j]*m2[i][j]);
            }
        }
        return r;
    }
    
    private Mat sumarPixeles(Mat imageBS, int lvl){
        lvl=lvl*4;
        for(int i=0;i<imageBS.rows();i++){
            for(int j=0;j<imageBS.cols();j++){
                double[] newSpec=imageBS.get(i, j);
                newSpec[0]= newSpec[0] + lvl;
                newSpec[1]= newSpec[1] + lvl;
                newSpec[2]= newSpec[2] + lvl;
                imageBS.put(i, j, newSpec);
            }
        }
        setImage(imageBS);
        return imageBS.clone();
    }
    
    private Mat restarPixeles(Mat imageBR, int lvl){
        lvl=lvl*-4;
        for(int i=0;i<imageBR.rows();i++){
            for(int j=0;j<imageBR.cols();j++){
                double[] newSpec=imageBR.get(i, j);
                newSpec[0]= newSpec[0] - lvl;
                newSpec[1]= newSpec[1] - lvl;
                newSpec[2]= newSpec[2] - lvl;
                imageBR.put(i, j, newSpec);
            }
        }
        setImage(imageBR);
        return imageBR.clone();
    }
    
    private void gamma(Mat imageG,double level){
        double gammaP,op;
        gammaP=1.00/level;
        
        for(int i=0;i<imageG.rows();i++){
            for(int j=0;j<imageG.cols();j++){
                double[] newSpec=imageG.get(i, j);
                
                op=newSpec[0]/255;
                op=Math.pow(op, gammaP);
                newSpec[0]= 255*op;
                
                op=newSpec[1]/255;
                op=Math.pow(op, gammaP);
                newSpec[1]= 255*op;
                
                op=newSpec[2]/255;
                op=Math.pow(op, gammaP);
                newSpec[2]= 255*op;
                
                imageG.put(i, j, newSpec);
            }
        }
        setImage(imageG);
        imageGa=imageG.clone();
    }
    
    private Mat contraste(Mat imageC, int level){
        double f;
 
        f=(259.0 * (level + 255))/(255 * (259 - level));
        
        for(int i=0;i<imageC.rows();i++){
            for(int j=0;j<imageC.cols();j++){
                double[] newSpec=imageC.get(i, j);

                newSpec[0]= f * (newSpec[0] - 128) + 128;
                newSpec[1]= f * (newSpec[1] - 128) + 128;
                newSpec[2]= f * (newSpec[2] - 128) + 128;
                imageC.put(i, j, newSpec);
            }
        }
        setImage(imageC);
        return imageC.clone();
    }
    
    private Mat negativo(Mat imageN){
        int nm=(int) Math.pow(2, 8);
        for(int i=0;i<imageN.rows();i++){
            for(int j=0;j<imageN.cols();j++){
                double[] newSpec=imageN.get(i, j);
                newSpec[0]= nm - 1 - newSpec[0] ;
                newSpec[1]= nm - 1 - newSpec[1] ;
                newSpec[2]= nm - 1 - newSpec[2] ;
                imageN.put(i, j, newSpec);
            }
        }
        setImage(imageN);
        return imageN;
    }
    
    private Mat binariza(Mat imageBi){
        double m;
        
        for(int i=0;i<imageBi.rows();i++){
            for(int j=0;j<imageBi.cols();j++){
                double[] newSpec=imageBi.get(i, j);
                
                m=Math.max(newSpec[0], newSpec[1]);
                m=Math.max(m, newSpec[2]);
                
                if(m<umbral){
                    newSpec[0]=0;
                    newSpec[1]=0;
                    newSpec[2]=0;
                } else{
                    newSpec[0]=255;
                    newSpec[1]=255;
                    newSpec[2]=255;
                }
                
                imageBi.put(i, j, newSpec);
            }
        }
        setImage(imageBi);
        return imageBi;
    }
    
    private Image toBufferedImage(Mat matrix){
        
        int type=BufferedImage.TYPE_BYTE_GRAY;
        if(matrix.channels()>1){
            type=BufferedImage.TYPE_3BYTE_BGR;
        }
        if(matrix.channels()>3){
            type=BufferedImage.TYPE_4BYTE_ABGR;
        }
        int bufferSize=matrix.channels()*matrix.cols()*matrix.rows();
        byte[] buffer= new byte[bufferSize];
        matrix.get(0, 0, buffer);
        BufferedImage image0=new BufferedImage(matrix.cols(), matrix.rows(), type);
        final byte[] targetPixels=((DataBufferByte) image0.getRaster().getDataBuffer()).getData();
        System.arraycopy(buffer, 0, targetPixels, 0, buffer.length);
        imag=image0;
        return image0;
    }
    
    private void setImage(Mat image){
        Image loadedImage = toBufferedImage(image);
        label.setIcon(new ImageIcon(loadedImage.getScaledInstance(this.label.getWidth(), this.label.getHeight(), Image.SCALE_DEFAULT)));
    }
    
    private void selectImage(){
        JFileChooser chooser=new JFileChooser();
        chooser.showDialog(null, null);
        
        File selectedFile=chooser.getSelectedFile();
        
        try{
            valorB=0;
            valorC=0;
            brillo.setValue(0);
            contraste.setValue(0);
            gamma.setValue(0);
            negativo.setSelected(false);
            binariza.setSelected(false);
            averaging.setValue(0);
            gaussian.setValue(0);
            median.setValue(0);
            rotar.setSelected(false);
            escalaE.setText("");
            grados.setText("");
            
            brillo.setEnabled(true);
            contraste.setEnabled(true);
            gamma.setEnabled(true);
            negativo.setEnabled(true);
            binariza.setEnabled(true);
            averaging.setEnabled(true);
            gaussian.setEnabled(true);
            median.setEnabled(true);
            rotar.setEnabled(true);
            guardar.setEnabled(true);
            original.setEnabled(true);
            escalaE.setEnabled(true);
            grados.setEnabled(true);
            
            Mat newImage=Imgcodecs.imread(selectedFile.getPath());
            this.image=newImage;
            image2=image.clone();
            setImage(newImage);
//            setImage2(newImage);
        } catch(Exception e){
            
        }
    }
    
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Principal().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JSlider averaging;
    private javax.swing.JCheckBox binariza;
    private javax.swing.JSlider brillo;
    private javax.swing.JButton cargar;
    private javax.swing.JSlider contraste;
    private javax.swing.JTextField escalaE;
    private javax.swing.JSlider gamma;
    private javax.swing.JSlider gaussian;
    private javax.swing.JTextField grados;
    private javax.swing.JButton guardar;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel label;
    private javax.swing.JSlider median;
    private javax.swing.JCheckBox negativo;
    private javax.swing.JButton original;
    private javax.swing.JCheckBox rotar;
    // End of variables declaration//GEN-END:variables

}
