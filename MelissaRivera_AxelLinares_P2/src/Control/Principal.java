

package Control;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JSlider;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;

public class Principal extends javax.swing.JFrame {
    
    JFileChooser save;
    Mat image,image2,imageGa,imageNeg,imageNeg2,imageBin,imageBin2,imageNF,imageAvg,imageGaussian,imageMedian;
    BufferedImage imag;
    int umbral=120,valorB=0,valorC=0,valorNeg=0,valorBin=0;
    double [][] avg = {{1.0/9, 1.0/9, 1.0/9}, {1.0/9, 1.0/9, 1.0/9}, {1.0/9, 1.0/9, 1.0/9}};
    double [][] gauss = {{1.0/16, 2.0/16, 1.0/16}, {2.0/16, 4.0/16, 2.0/16}, {1.0/16, 2.0/16, 1.0/16}};
    
    public Principal() {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        initComponents();
        save=new JFileChooser();
        brillo.setEnabled(false);
        contraste.setEnabled(false);
        gamma.setEnabled(false);
        negativo.setEnabled(false);
        binariza.setEnabled(false);
        averaging.setEnabled(false);
        gaussian.setEnabled(false);
        median.setEnabled(false);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        label = new javax.swing.JLabel();
        cargar = new javax.swing.JButton();
        brillo = new javax.swing.JSlider();
        contraste = new javax.swing.JSlider();
        negativo = new javax.swing.JCheckBox();
        gamma = new javax.swing.JSlider();
        binariza = new javax.swing.JCheckBox();
        guardar = new javax.swing.JButton();
        original = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        averaging = new javax.swing.JSlider();
        gaussian = new javax.swing.JSlider();
        median = new javax.swing.JSlider();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        cargar.setText("Cargar");
        cargar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cargarActionPerformed(evt);
            }
        });

        brillo.setMajorTickSpacing(1);
        brillo.setMaximum(10);
        brillo.setMinimum(-10);
        brillo.setPaintTicks(true);
        brillo.setToolTipText("");
        brillo.setValue(0);
        brillo.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                brilloStateChanged(evt);
            }
        });

        contraste.setMajorTickSpacing(1);
        contraste.setMaximum(10);
        contraste.setMinimum(-10);
        contraste.setPaintTicks(true);
        contraste.setValue(0);
        contraste.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                contrasteStateChanged(evt);
            }
        });

        negativo.setText("Negativo");
        negativo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                negativoActionPerformed(evt);
            }
        });

        gamma.setMajorTickSpacing(1);
        gamma.setMaximum(5);
        gamma.setPaintTicks(true);
        gamma.setToolTipText("");
        gamma.setValue(0);
        gamma.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                gammaStateChanged(evt);
            }
        });

        binariza.setText("Binarizaci√≥n");
        binariza.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binarizaActionPerformed(evt);
            }
        });

        guardar.setText("Guardar");
        guardar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                guardarActionPerformed(evt);
            }
        });

        original.setText("Original");
        original.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                originalActionPerformed(evt);
            }
        });

        jLabel1.setText("Gamma");

        jLabel2.setText("Contraste");

        jLabel3.setText("Brillo");

        jLabel4.setText("Averaging");

        jLabel5.setText("Median");

        jLabel6.setText("Gaussian");

        averaging.setMajorTickSpacing(1);
        averaging.setMaximum(5);
        averaging.setPaintTicks(true);
        averaging.setToolTipText("");
        averaging.setValue(0);
        averaging.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                averagingStateChanged(evt);
            }
        });

        gaussian.setMajorTickSpacing(1);
        gaussian.setMaximum(5);
        gaussian.setPaintTicks(true);
        gaussian.setValue(0);
        gaussian.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                gaussianStateChanged(evt);
            }
        });

        median.setMajorTickSpacing(1);
        median.setMaximum(5);
        median.setPaintTicks(true);
        median.setValue(0);
        median.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                medianStateChanged(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(308, 308, 308)
                        .addComponent(jLabel3))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(302, 302, 302)
                        .addComponent(jLabel2))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(307, 307, 307)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(cargar, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(guardar, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(original, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(label, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(brillo, javax.swing.GroupLayout.DEFAULT_SIZE, 580, Short.MAX_VALUE)
                                .addComponent(contraste, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(gamma, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(averaging, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(gaussian, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(median, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(298, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(negativo)
                        .addGap(34, 34, 34)
                        .addComponent(binariza)
                        .addGap(64, 64, 64))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addGap(305, 305, 305))))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jLabel6)
                .addGap(304, 304, 304))
            .addGroup(layout.createSequentialGroup()
                .addGap(309, 309, 309)
                .addComponent(jLabel5)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(label, javax.swing.GroupLayout.PREFERRED_SIZE, 380, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(brillo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(contraste, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(gamma, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(averaging, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(gaussian, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(median, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 40, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(binariza)
                    .addComponent(negativo)
                    .addComponent(original)
                    .addComponent(guardar)
                    .addComponent(cargar))
                .addGap(22, 22, 22))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    
    
    private void cargarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cargarActionPerformed
        selectImage();
        image2=image.clone();
    }//GEN-LAST:event_cargarActionPerformed

    private void brilloStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_brilloStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=(int)source.getValue();

        if(contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
            if(level>0){
                valorB=level;
                sumarPixeles(image.clone(),level);
            }
            else if(level<0){
                valorB=level;
                restarPixeles(image.clone(), level);
            }
            else{
                valorB=level;
                image2=image.clone();
                setImage(image); 
            }
        }
        else {
            if(gamma.getValue()>0 && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                if (valorB>level){
                    valorB=level;
                    imageGa=restarPixeles(imageGa.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    imageGa=sumarPixeles(imageGa.clone(),1);
                }
            }
            else if(gamma.getValue()>0 && (averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0)){
                if (valorB>level){
                    valorB=level;
                    imageGa=restarPixeles(imageGa.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    imageGa=sumarPixeles(imageGa.clone(),1);
                }
            }
            else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                if (valorB>level){
                    valorB=level;
                    imageNF=restarPixeles(imageNF.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    imageNF=sumarPixeles(imageNF.clone(),1);
                }
            }
            else{
                if (valorB>level){
                    valorB=level;
                    image2=restarPixeles(image2.clone(), -1);
                }
                else if(valorB<level){
                    valorB=level;
                    image2=sumarPixeles(image2.clone(),1);
                }
            }
        }
    }//GEN-LAST:event_brilloStateChanged

    private void contrasteStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_contrasteStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=(int)source.getValue();
        
        if(brillo.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
            if(level<0){
                valorC=level;
                level=level*5;
                contraste(image.clone(),level);
            }
            else if(level>0){
                valorC=level;
                level=level*5;
                contraste(image.clone(),level);
            }
            else{
                valorC=level;
                image2=image.clone();
                setImage(image); 
            }
        } else{
            if(gamma.getValue()>0 && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                if(valorC>level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),5);
                }
            }
            else if(gamma.getValue()>0 && (averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0)){
                if(valorC>level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    imageGa=contraste(imageGa.clone(),5);
                }
            }
            else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                if(valorC>level){
                    valorC=level;
                    imageNF=contraste(imageNF.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    imageNF=contraste(imageNF.clone(),5);
                }
            }
            else{
                if(valorC>level){
                    valorC=level;
                    image2=contraste(image2.clone(),-5);
                }
                else if(valorC<level){
                    valorC=level;
                    image2=contraste(image2.clone(),5);
                }
            }
        }
    }//GEN-LAST:event_contrasteStateChanged

    private void negativoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_negativoActionPerformed
        if(negativo.isSelected()==true){
            if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                valorNeg=1;
                image2=negativo(image.clone());
            } 
            else{
                imageNeg=image2.clone();
                
                if(gamma.getValue()>0){
                    valorNeg=2;
                    imageNeg2=imageGa.clone();
                    
                    image2=negativo(image2.clone());
                    imageGa=negativo(imageGa.clone());   
                }
                else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0 ){
                    valorNeg=4;
                    imageNeg2=imageNF.clone();
                    
                    image2=negativo(image2.clone());
                    imageNF=negativo(imageNF.clone());   
                }
                else{
                    valorNeg=3;
                    image2=negativo(image2.clone());
                }
               
            }
        } else{
            switch (valorNeg) {
                case 1:
                    image2=image.clone();
                    setImage(image);
                    break;
                case 2:
                    image2=imageNeg.clone();
                    imageGa=imageNeg2.clone();
                    setImage(imageGa);
                    break;
                case 3:
                    image2=imageNeg.clone();
                    setImage(image2);
                    break;
                case 4:
                    image2=imageNeg.clone();
                    imageNF=imageNeg2.clone();
                    setImage(imageNF);
                    break;
            }
        }
    }//GEN-LAST:event_negativoActionPerformed

    private void gammaStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_gammaStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        double g;
        
        if(contraste.getValue()==0 && brillo.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
            if(level>0){
                g=level*1.05;
                gamma(image.clone(),g);
            }
            else{
                image2=image.clone();
                setImage(image); 
            }
        }
        else{
            if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                if(level>0){
                    g=level*1.05;
                    gamma(imageNF.clone(),g);
                }
                else{
                    setImage(imageNF); 
                }
            } else{
                if(level>0){
                    g=level*1.05;
                    gamma(image2.clone(),g);
                }
                else{
                    setImage(image2); 
                }
            }
        }
        
        
    }//GEN-LAST:event_gammaStateChanged

    private void binarizaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binarizaActionPerformed
        if(binariza.isSelected()==true){
            if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0 && median.getValue()==0){
                valorBin=1;
                image2=binariza(image.clone());
            } 
            else{
                imageBin=image2.clone();
                
                if(gamma.getValue()>0){
                    valorBin=2;
                    imageBin2=imageGa.clone();
                    
                    image2=binariza(image2.clone());
                    imageGa=binariza(imageGa.clone());   
                }
                else if(averaging.getValue()>0 || gaussian.getValue()>0 || median.getValue()>0){
                    valorBin=3;
                    imageBin2=imageNF.clone();
                    
                    image2=binariza(imageNF.clone());
                    imageNF=binariza(imageNF.clone());  
                }
                else{
                    valorBin=4;
                    image2=binariza(image2.clone());
                }
            }
        } else{
             switch (valorBin) {
                case 1:
                    image2=image.clone();
                    setImage(image);
                    break;
                case 2:
                    image2=imageBin.clone();
                    imageGa=imageBin2.clone();
                    setImage(imageGa);
                    break;
                case 3:
                    image2=imageBin.clone();
                    imageNF=imageBin2.clone();
                    setImage(imageNF);
                    break;
                case 4:
                    image2=imageBin.clone();
                    setImage(image2);
                    break;
            }
        }
    }//GEN-LAST:event_binarizaActionPerformed

    private void guardarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_guardarActionPerformed
        save.showSaveDialog(this);
       
        try {
            ImageIO.write(imag, "png",save.getSelectedFile());
        } catch (IOException e) {
        }
    }//GEN-LAST:event_guardarActionPerformed

    private void originalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_originalActionPerformed
        valorB=0;
        valorC=0;
        brillo.setValue(0);
        contraste.setValue(0);
        gamma.setValue(0);
        negativo.setSelected(false);
        binariza.setSelected(false);
        averaging.setValue(0);
        gaussian.setValue(0);
        median.setValue(0);
        
        image2=image.clone();
        setImage(image);
    }//GEN-LAST:event_originalActionPerformed

    private void averagingStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_averagingStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        Mat imageAux;
        
        if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && gaussian.getValue()==0 && median.getValue()==0){
            if(averaging.getValue()>0){
                imageAux=image.clone();
                for(int i=1;i<=level;i++){
                averaging(imageAux);
                }
            }
            else{
                image2=image.clone();
                setImage(image);
            }
        } else{
            if(gamma.getValue()>0 && gaussian.getValue()==0 && median.getValue()==0){
                if(averaging.getValue()>0){
                    imageAux=imageGa.clone();
                    for(int i=1;i<=level;i++){
                    averaging(imageAux);
                    }
                    imageGa=imageNF.clone();
                } else{
//                    imageGa=imageAvg.clone();
                    setImage(imageGa);
                }
            }
            else if(gaussian.getValue()>0 || median.getValue()>0){
                if(averaging.getValue()>0){
                    imageAvg=imageNF.clone();
                    imageAux=imageNF.clone();
                    for(int i=1;i<=level;i++){
                    averaging(imageAux);
                    }
                    imageNF=imageAvg.clone();
                } else{
                    setImage(imageNF);
                }
            } else{
                if(averaging.getValue()>0){
                    imageAux=image2.clone();
                    for(int i=1;i<=level;i++){
                    averaging(imageAux);
                    }
                } else{
                    setImage(image2);
                }
            }
        }
    }//GEN-LAST:event_averagingStateChanged

    private void gaussianStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_gaussianStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        Mat imageAux;
        
        if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && median.getValue()==0){
            if(gaussian.getValue()>0){
                imageAux=image.clone();
                for(int i=1;i<=level;i++){
                gaussian(imageAux);
                }
            }
            else{
                image2=image.clone();
                setImage(image);
            }
        } else{
            if(gamma.getValue()>0 && averaging.getValue()==0 && median.getValue()==0){
                if(gaussian.getValue()>0){
                    imageAux=imageGa.clone();
                    for(int i=1;i<=level;i++){
                    gaussian(imageAux);
                    }
                    imageGa=imageNF.clone();
                } else{
                    setImage(imageGa);
                }
            }
            else if(averaging.getValue()>0 || median.getValue()>0){
                if(gaussian.getValue()>0){
                    imageGaussian=imageNF.clone();
                    imageAux=imageNF.clone();
                    for(int i=1;i<=level;i++){
                    gaussian(imageAux);
                    }
                    imageNF=imageGaussian.clone();
                } else{
                    setImage(imageNF);
                }
            } else{
                if(gaussian.getValue()>0){
                    imageAux=image2.clone();
                    for(int i=1;i<=level;i++){
                    gaussian(imageAux);
                    }
                } else{
                    setImage(image2);
                }
            }
        }
    }//GEN-LAST:event_gaussianStateChanged

    private void medianStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_medianStateChanged
        JSlider source=(JSlider)evt.getSource();
        int level=source.getValue();
        Mat imageAux;
        
        if(brillo.getValue()==0 && contraste.getValue()==0 && gamma.getValue()==0 && negativo.isSelected()==false && binariza.isSelected()==false && averaging.getValue()==0 && gaussian.getValue()==0){
            if(median.getValue()>0){
                imageAux=image.clone();
                for(int i=1;i<=level;i++){
                median(imageAux);
                }
            }
            else{
                image2=image.clone();
                setImage(image);
            }
        } else{
            if(gamma.getValue()>0 && averaging.getValue()==0 && gaussian.getValue()==0){
                if(median.getValue()>0){
                    imageAux=imageGa.clone();
                    for(int i=1;i<=level;i++){
                    median(imageAux);
                    }
                    imageGa=imageNF.clone();
                } else{
                    setImage(imageGa);
                }
            }
            else if(averaging.getValue()>0 || gaussian.getValue()>0){
                if(median.getValue()>0){
                    imageMedian=imageNF.clone();
                    imageAux=imageNF.clone();
                    for(int i=1;i<=level;i++){
                    median(imageAux);
                    }
                    imageNF=imageMedian.clone();
                } else{
                    setImage(imageNF);
                }
            } else{
                if(median.getValue()>0){
                    imageAux=image2.clone();
                    for(int i=1;i<=level;i++){
                    median(imageAux);
                    }
                } else{
                    setImage(image2);
                }
            }
        }
    }//GEN-LAST:event_medianStateChanged

    private void averaging(Mat imageAv){
        double[][] m0 = new double[3][3];
        double[][] m1 = new double[3][3];
        double[][] m2 = new double[3][3];
        int x,y;
        for(int i=0;i<imageAv.rows();i++){
            for(int j=0;j<imageAv.cols();j++){
                if(i>0 && i<imageAv.rows()-1 && j>0 && j<imageAv.cols()-1){
                    double[] newSpec;

                    x=0;
                    for(int a=i-1; a<i+2; a++){
                        y=0;
                        for(int b=j-1; b<j+2; b++){

                            newSpec=imageAv.get(a, b);
                            m0[x][y]=newSpec[0];
                            m1[x][y]=newSpec[1];
                            m2[x][y]=newSpec[2];
                            y++;
                        }
                    x++;    
                    }
                    newSpec=imageAv.get(i, j);
                    newSpec[0]=operacion(m0,avg);
                    newSpec[1]=operacion(m1,avg);
                    newSpec[2]=operacion(m2,avg);
                    
                    imageAv.put(i,j,newSpec);
                }

            }
            
        }
        setImage(imageAv);
        imageNF=imageAv.clone();
    }
    
    private void gaussian(Mat imageGauss){
        double[][] m0 = new double[3][3];
        double[][] m1 = new double[3][3];
        double[][] m2 = new double[3][3];
        int x,y;
        for(int i=0;i<imageGauss.rows();i++){
            for(int j=0;j<imageGauss.cols();j++){
                if(i>0 && i<imageGauss.rows()-1 && j>0 && j<imageGauss.cols()-1){
                    double[] newSpec;

                    x=0;
                    for(int a=i-1; a<i+2; a++){
                        y=0;
                        for(int b=j-1; b<j+2; b++){

                            newSpec=imageGauss.get(a, b);
                            m0[x][y]=newSpec[0];
                            m1[x][y]=newSpec[1];
                            m2[x][y]=newSpec[2];
                            y++;
                        }
                    x++;    
                    }
                    newSpec=imageGauss.get(i, j);
                    newSpec[0]=operacion(m0,gauss);
                    newSpec[1]=operacion(m1,gauss);
                    newSpec[2]=operacion(m2,gauss);
                    
                    imageGauss.put(i,j,newSpec);
                }

            }
            
        }
        setImage(imageGauss);
        imageNF=imageGauss.clone();
    }
    
    private void median(Mat imageMed){
        double[] m0 = new double[9];
        double[] m1 = new double[9];
        double[] m2 = new double[9];
        int x;
        for(int i=0;i<imageMed.rows();i++){
            for(int j=0;j<imageMed.cols();j++){
                
                if(i>0 && i<imageMed.rows()-1 && j>0 && j<imageMed.cols()-1){
                    double[] newSpec;

                    x=0;
                    for(int a=i-1; a<i+2; a++){
                        for(int b=j-1; b<j+2; b++){

                            newSpec=imageMed.get(a, b);
                            m0[x]=newSpec[0];
                            m1[x]=newSpec[1];
                            m2[x]=newSpec[2];
                            x++;
                        }    
                    }
                    newSpec=imageMed.get(i, j);
                    
                    Arrays.sort(m0);
                    Arrays.sort(m1);
                    Arrays.sort(m2);
                    
                    newSpec[0]=m0[4];
                    newSpec[1]=m1[4];
                    newSpec[2]=m2[4];
                    
                    imageMed.put(i,j,newSpec);
                }

            }
        }
        setImage(imageMed);
        imageNF=imageMed.clone();
    }
    
    private double operacion(double[][] m1,double[][] m2){
        double r=0;
        
        for(int i=0; i<3;i++){
            for(int j=0;j<3;j++){
                r=r+(m1[i][j]*m2[i][j]);
            }
        }
        return r;
    }
    
    private Mat sumarPixeles(Mat imageBS, int lvl){
        lvl=lvl*4;
        for(int i=0;i<imageBS.rows();i++){
            for(int j=0;j<imageBS.cols();j++){
                double[] newSpec=imageBS.get(i, j);
                newSpec[0]= newSpec[0] + lvl;
                newSpec[1]= newSpec[1] + lvl;
                newSpec[2]= newSpec[2] + lvl;
                imageBS.put(i, j, newSpec);
            }
        }
        setImage(imageBS);
        return imageBS.clone();
    }
    
    private Mat restarPixeles(Mat imageBR, int lvl){
        lvl=lvl*-4;
        for(int i=0;i<imageBR.rows();i++){
            for(int j=0;j<imageBR.cols();j++){
                double[] newSpec=imageBR.get(i, j);
                newSpec[0]= newSpec[0] - lvl;
                newSpec[1]= newSpec[1] - lvl;
                newSpec[2]= newSpec[2] - lvl;
                imageBR.put(i, j, newSpec);
            }
        }
        setImage(imageBR);
        return imageBR.clone();
    }
    
    private void gamma(Mat imageG,double level){
        double gammaP,op;
        gammaP=1.00/level;
        
        for(int i=0;i<imageG.rows();i++){
            for(int j=0;j<imageG.cols();j++){
                double[] newSpec=imageG.get(i, j);
                
                op=newSpec[0]/255;
                op=Math.pow(op, gammaP);
                newSpec[0]= 255*op;
                
                op=newSpec[1]/255;
                op=Math.pow(op, gammaP);
                newSpec[1]= 255*op;
                
                op=newSpec[2]/255;
                op=Math.pow(op, gammaP);
                newSpec[2]= 255*op;
                
                imageG.put(i, j, newSpec);
            }
        }
        setImage(imageG);
        imageGa=imageG.clone();
    }
    
    private Mat contraste(Mat imageC, int level){
        double f;
 
        f=(259.0 * (level + 255))/(255 * (259 - level));
        
        for(int i=0;i<imageC.rows();i++){
            for(int j=0;j<imageC.cols();j++){
                double[] newSpec=imageC.get(i, j);

                newSpec[0]= f * (newSpec[0] - 128) + 128;
                newSpec[1]= f * (newSpec[1] - 128) + 128;
                newSpec[2]= f * (newSpec[2] - 128) + 128;
                imageC.put(i, j, newSpec);
            }
        }
        setImage(imageC);
        return imageC.clone();
    }
    
    private Mat negativo(Mat imageN){
        int nm=(int) Math.pow(2, 8);
        for(int i=0;i<imageN.rows();i++){
            for(int j=0;j<imageN.cols();j++){
                double[] newSpec=imageN.get(i, j);
                newSpec[0]= nm - 1 - newSpec[0] ;
                newSpec[1]= nm - 1 - newSpec[1] ;
                newSpec[2]= nm - 1 - newSpec[2] ;
                imageN.put(i, j, newSpec);
            }
        }
        setImage(imageN);
        return imageN;
    }
    
    private Mat binariza(Mat imageBi){
        double m;
        
        for(int i=0;i<imageBi.rows();i++){
            for(int j=0;j<imageBi.cols();j++){
                double[] newSpec=imageBi.get(i, j);
                
                m=Math.max(newSpec[0], newSpec[1]);
                m=Math.max(m, newSpec[2]);
                
                if(m<umbral){
                    newSpec[0]=0;
                    newSpec[1]=0;
                    newSpec[2]=0;
                } else{
                    newSpec[0]=255;
                    newSpec[1]=255;
                    newSpec[2]=255;
                }
                
                imageBi.put(i, j, newSpec);
            }
        }
        setImage(imageBi);
        return imageBi;
    }
    
    private Image toBufferedImage(Mat matrix){
        
        int type=BufferedImage.TYPE_BYTE_GRAY;
        if(matrix.channels()>1){
            type=BufferedImage.TYPE_3BYTE_BGR;
        }
        if(matrix.channels()>3){
            type=BufferedImage.TYPE_4BYTE_ABGR;
        }
        int bufferSize=matrix.channels()*matrix.cols()*matrix.rows();
        byte[] buffer= new byte[bufferSize];
        matrix.get(0, 0, buffer);
        BufferedImage image0=new BufferedImage(matrix.cols(), matrix.rows(), type);
        final byte[] targetPixels=((DataBufferByte) image0.getRaster().getDataBuffer()).getData();
        System.arraycopy(buffer, 0, targetPixels, 0, buffer.length);
        imag=image0;
        return image0;
    }
    
    private void setImage(Mat image){
        Image loadedImage = toBufferedImage(image);
        label.setIcon(new ImageIcon(loadedImage.getScaledInstance(this.label.getWidth(), this.label.getHeight(), Image.SCALE_DEFAULT)));
    }
    
    private void selectImage(){
        JFileChooser chooser=new JFileChooser();
        chooser.showDialog(null, null);
        
        File selectedFile=chooser.getSelectedFile();
        
        try{
            valorB=0;
            valorC=0;
            brillo.setValue(0);
            contraste.setValue(0);
            gamma.setValue(0);
            negativo.setSelected(false);
            binariza.setSelected(false);
            averaging.setValue(0);
            gaussian.setValue(0);
            median.setValue(0);
            
            brillo.setEnabled(true);
            contraste.setEnabled(true);
            gamma.setEnabled(true);
            negativo.setEnabled(true);
            binariza.setEnabled(true);
            averaging.setEnabled(true);
            gaussian.setEnabled(true);
            median.setEnabled(true);
            
            Mat newImage=Imgcodecs.imread(selectedFile.getPath());
            this.image=newImage;
            image2=image.clone();
            setImage(newImage);
//            setImage2(newImage);
        } catch(Exception e){
            
        }
    }
    
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Principal().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JSlider averaging;
    private javax.swing.JCheckBox binariza;
    private javax.swing.JSlider brillo;
    private javax.swing.JButton cargar;
    private javax.swing.JSlider contraste;
    private javax.swing.JSlider gamma;
    private javax.swing.JSlider gaussian;
    private javax.swing.JButton guardar;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel label;
    private javax.swing.JSlider median;
    private javax.swing.JCheckBox negativo;
    private javax.swing.JButton original;
    // End of variables declaration//GEN-END:variables

}
